#!/usr/bin/env python

import os
import sys
import argparse

import nibabel as nib
import numpy as np

def main(image_path, bval_path, bvec_path, dtk_paths):
    ## Open files.
    nii = nib.load(image_path[0])
    arr = nii.get_fdata()
    
    bval = np.loadtxt(bval_path[0], dtype=str)
    if not bvec_path is None:
        bvec = np.loadtxt(bvec_path[0], dtype=str)

    ## Check that all three inputs have the same number of volumes.
    try:
        if (bval.shape != (arr.shape[3],)) or ((bvec_path is not None) and (bvec.shape != (3, arr.shape[3]))):
            dim_error = True
        else: 
            dim_error = False
    except IndexError:
        dim_error = True
    if dim_error:
        msg = f"Image volume dimension does not match BVAL or BVEC file. Expecting image dim4 to match number of columns in BVAL and BVEC files."
        msg += f"\n  Image dimensions:\t{arr.shape}"
        msg += f"\n  BVAL dimensions:\t{bval.shape}"
        if not bvec_path is None:
            msg += f"\n  BVEC dimensions:\t{bvec.shape}"
        raise Exception(msg)

    ## Reorder volumes.
    # Find new index order.
    index_first = np.where(bval.astype(float)==0.0)[0] # indices of the b=0 volumes
    index_last = np.where(bval.astype(float)!=0.0)[0] # indices of the b!=0 volumes
    index = np.append(index_first, index_last)

    assert(len(index) == arr.shape[3]) # verify sanity
    
    # Reorder.
    arr_out = arr[:, :, :, index]
    bval_out = bval[index]
    if not bvec_path is None:
        bvec_out = bvec[:, index]

    ## Save.
    nii_out = nib.nifti1.Nifti1Image(arr_out, nii.affine, header=nii.header) # Create NIFTI object using new array and old affine & header.
    nib.save(nii_out, image_path[1])

    bval_out = bval_out.reshape(1, -1) # want a single row, not a single column
    np.savetxt(bval_path[1], bval_out, delimiter=' ', fmt='%s')

    if not bvec_path is None:
        np.savetxt(bvec_path[1], bvec_out, delimiter='  ', fmt='%s')

    # Save the combined BVEC and BVAL CSV file.
    if (not dtk_paths is None):
        combined = np.concatenate([bvec_out.T, bval_out.T], axis=1)
        num_b0_vols = np.count_nonzero(combined[:,3] == '0') # Count the b=0 rows.
        combined = combined[combined[:,3]!='0', :] # Remove the b=0 rows.

        np.savetxt(dtk_paths[0], combined, delimiter=', ', fmt='%s')

        with open(dtk_paths[1], 'w') as handle:
            handle.write(str(num_b0_vols)+'\n')
    return

if (__name__ == '__main__'):
    # Create argument parser.
    description = """Reorder volumes in a diffusion MRI series such that all b=0 volumes are first, as required by the Diffusion Toolkit functions dti_recon and odf_recon."""
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    # Define positional arguments.
#    parser.add_argument("", help="")
    
    # Define optional arguments.
    parser.add_argument("-i", "--image_path", help="diffusion MRI image in NIFTI format", type=str, nargs=2, metavar=('IN_PATH', 'OUT_PATH'), required=True)
    parser.add_argument("-b", "--bval_path", help="b value file, as generated by dcm2niix", type=str, nargs=2, metavar=('IN_PATH', 'OUT_PATH'), required=True)
    parser.add_argument("-g", "--bvec_path", help="gradient direction file, as generated by dcm2niix", type=str, nargs=2, metavar=('IN_PATH', 'OUT_PATH'))
    parser.add_argument("--dtk_paths", help="output paths of a combined BVEC and BVAL file with b=0 volumes removed, in CSV format; and a text file indicating the number of b=0 volumes in the series, as required by the Diffusion Toolkit functions dti_recon and odf_recon", metavar=('BVEC_BVAL_PATH', 'NUM_B0_VOLS_PATH'), nargs=2, type=str)

    # Print help if no arguments input.
    if (len(sys.argv) == 1):
        parser.print_help()
        sys.exit()

    # Parse arguments.
    args = parser.parse_args()

    # Run main function.
    main(**vars(args))
