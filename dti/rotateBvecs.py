#!/usr/bin/env python3

import os
import sys
import argparse

import numpy as np

#MNI Transform File
#%Tue Oct 18 09:42:42 2022>>> xfmconcat -clobber /gpfs/fs0/scratch/m/mchakrav/tguo/SK010002_V01_20130527/output/registrations/SK010002_V01_20130527_b0n4/SK010002_V01_20130527_T2n4/ATlin.xfm /gpfs/fs0/scratch/m/mchakrav/tguo/SK010002_V01_20130527/output/registrations/SK010002_V01_20130527_b0n4/SK010002_V01_20130527_T2n4/TAnl1_inverse_NL.xfm /gpfs/fs0/scratch/m/mchakrav/tguo/SK010002_V01_20130527/output/registrations/SK010002_V01_20130527_b0n4/SK010002_V01_20130527_T2n4/nl.xfm
#
#Transform_Type = Linear;
#Linear_Transform =
# 1.00665479153072 -0.0200719476008483 -0.0172152366670218 2.76721436251976
# 0.00952038949024048 1.01237732177131 -0.0533227806715948 3.5161804548646
# 0.0173429983578564 0.0297434770618022 1.04028275342112 -24.9211461080166;
#Transform_Type = Grid_Transform;
#Displacement_Volume = nl_grid_0.mnc;

def main(affine_path, bvec_in_path, bvec_out_path, affine_format, normalize):
    if affine_format == 'fsl_mat':
        M = np.loadtxt(affine_path) 
        A = M[:3,:3] # rotate, stretch, shear portion of matrix
    elif affine_format == 'mnc_xfm':
        with open(affine_path, 'r') as handle:
            transform_lines = handle.readlines()
        for line_num, line in enumerate(transform_lines):
            if line == 'Linear_Transform =\n':
                M_lines = transform_lines[line_num+1:line_num+4]
                break

        # Remove junk
        M_lines = [line.strip(' ;\n') for line in M_lines]
        
        # Get first three numbers from each line.
        A_lines = [line.split(' ')[:3] for line in M_lines]

        # Convert strings to floats.
        for i, row in enumerate(A_lines):
            for j, value, in enumerate(row):
                A_lines[i][j] = float(value)

        # Convert to numpy array.
        A = np.array(A_lines)
    else:
        err_msg = f'Unhandled affine transformation format: {affine_format}'
        raise Exception(err_msg)
    X = np.loadtxt(bvec_in_path)

    Y = A.dot(X)

    # Normalize vectors
    if normalize:
        for col in range(Y.shape[1]):
            length = np.linalg.norm(Y[:, col])
            if length > 0:
                Y[:, col] = Y[:, col]/length

    # Print vector lengths.
    for col_num, col in enumerate(range(X.shape[1])):
        old_length = np.linalg.norm(X[:, col])
        new_length = np.linalg.norm(Y[:, col])
        print(f'Volume number: {col_num}')
        print(f'Old BVEC length: {np.linalg.norm(X[:, col])}')
        print(f'New BVEC length: {np.linalg.norm(Y[:, col])}')
        if (old_length < 0.1) and (new_length > 0.1):
            print(f'Warning: A zero vector may have been converted to a unit vector by mistake.')
        print('-'*40)
    np.savetxt(bvec_out_path, Y, delimiter='  ', fmt='%.10g')
    return

if (__name__ == '__main__'):
    # Create argument parser.
    description = """Apply affine transformation to FSL BVEC files. By default, assume affine transformation is in the format generated by FSL FLIRT."""
    parser = argparse.ArgumentParser(description=description, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    # Define positional arguments.
    parser.add_argument("affine_path", help="path to affine matrix file (a 4x4 matrix with two-space-separated values, as output by FSL FLIRT).")
    parser.add_argument("bvec_in_path", help="path to input bvec file")
    parser.add_argument("bvec_out_path", help="path to output bvec file")
    
    # Define optional arguments.
    parser.add_argument("-a", "--affine_format", help="format of input transformation file", type=str, choices=['fsl_mat', 'mnc_xfm'], default='fsl_mat')
    parser.add_argument("-n", "--normalize", help="set vector lengths to 1 or 0 after applying transform", action='store_true')
    
    # Print help if no arguments input.
    if (len(sys.argv) == 1):
        parser.print_help()
        sys.exit()

    # Parse arguments.
    args = parser.parse_args()

    # Run main function.
    main(**vars(args))
